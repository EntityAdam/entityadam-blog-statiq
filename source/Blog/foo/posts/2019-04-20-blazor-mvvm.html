<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <title>My Blog - Server Side Blazor Code Re-Use using MVVM</title>

  <link rel="canonical" href='/posts/2019-04-20-blazor-mvvm'>

      <link type="application/rss+xml" rel="alternate" href="/feed.rss" />
      <link type="application/atom+xml" rel="alternate" href="/feed.atom" />

  <meta name="application-name" content='My Blog' />
  <meta name="msapplication-tooltip" content='My Blog' />
  <meta name="msapplication-starturl" content='/' />

  <meta property="og:title" content='My Blog - Server Side Blazor Code Re-Use using MVVM' />
    <meta property="og:image" content='/posts/img/adam-avatar-final-trans-400.png' />
  <meta property="og:type" content="website" />
  <meta property="og:url" content='/posts/2019-04-20-blazor-mvvm' />

  <link rel="icon" href='/favicon.ico'>

  <!-- Custom fonts for this template -->
  <link href='/vendor/fontawesome-free/css/all.min.css' rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" data-no-mirror>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" data-no-mirror>

  <!-- Styles for this template (also includes Bootstrap) -->
  <link href='/scss/clean-blog.css' rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" data-no-mirror></script>
  <script src="https://cdn.jsdelivr.net/npm/quicklink@2.3.0/dist/quicklink.umd.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism.css" rel="stylesheet">

  


  

</head>

<body>

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href='/'>My Blog</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ms-auto">
          <li class="nav-item">
    <a class="nav-link" href="/posts">Posts</a>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="/tags">Tags</a>
  </li>

      </ul>
    </div>
  </div>
</nav>


  <!-- Page Header -->
  <header class="masthead" style="background-image: url(&quot;/posts/img/adam-avatar-final-trans-400.png&quot;)">
  <div class="container position-relative">
    <div class="row">
      <div class="col-md-12">
        <div class='post-heading'>
          <h1>
            Server Side Blazor Code Re-Use using MVVM
          </h1>
            <div class="meta">Published on Saturday, April 20, 2019</div>
              <div class="mt-3">
                  <a href="/tags/blazor" class="badge text-bg-light"> Blazor</a>
              </div>
        </div>
      </div>
    </div>
  </div>
</header>


  <!-- Main Content -->
  <div class="container">
    <div class="row">
      <div id="content" class="col-md-12">
        <p>While MVVM is not 'officially' supported in Blazor, MVVM after all is just a design pattern and I'm going to demonstrate that you can actually use the MVVM pattern with Blazor and potentially share or re-use some of the code with WPF or Xamarin Forms.</p>
<h1 id="server-side-blazor-code-re-use-using-mvvm">Server Side Blazor Code Re-Use using MVVM</h1>
<p>Author: Adam Vincent</p>
<p>GitHub Repository: <a href="https://github.com/EntityAdam/HappyStorage">HappyStorage</a></p>
<h2 id="what-is-mvvm">What is MVVM?</h2>
<p>In a nutshell, MVVM is a design pattern derived from the Model-View-Presenter (MVP) pattern. The Model-View-Controller (MVC) pattern is also derived from MVP, but where MVC is suited to sit on top of a stateless HTTP protocol, MVVM is suited for user interface (UI) platforms with state and two way data binding.  MVVM is commonly implemented in Desktop (WPF / UWP), Web (Silverlight), and Mobile (Xamarin.Forms) applications.  Like the other frameworks, Blazor acts much like a Single Page Application (SPA) that has two way data binding, and can benefit from the MVVM pattern. So whether you have existing MVVM code in the form of a WPF or mobile application, or are starting green with new code you can leverage MVVM to re-use your existing code in Blazor, or share your code with other platforms respectively.</p>
<p><img src="MVVMPattern.png" alt="" /></p>
<blockquote>
<p>More information on MVVM: <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel">Wikipedia</a></p>
</blockquote>
<hr />
<h2 id="example-presentation-layer">Example Presentation Layer</h2>
<h3 id="bindablebase">BindableBase</h3>
<p>At the heart of MVVM is the <code>INotifyPropertyChanged</code> interface which notifies clients that a property has changed. It is through this interface that converts a user interaction into your code being called. Usually, all ViewModels, and some Models will implement <code>INotifyPropertyChanged</code> therefore, it is common to either use a library (Prism, MVVM Light, Caliburn) or create your own base class.  Here is a minimal implementation of INPC.</p>
<pre><code class="language-cs">public abstract class BindableBase : INotifyPropertyChanged
{
    protected bool SetField&lt;T&gt;(ref T field, T value, [CallerMemberName] string propertyName = null)
    {
        if (EqualityComparer&lt;T&gt;.Default.Equals(field, value)) return false;
        field = value;
        OnPropertyChanged(propertyName);
        return true;
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
</code></pre>
<p>In this simplified model class which derives from <code>BindableBase</code>, we have a <code>CustomerModel</code> with a single property <code>FirstName</code>.  In this context, we would probably have a Customer filling out an <code>&lt;input&gt;</code> within a <code>&lt;form&gt;</code> on a website where they must fill in their first name. This input would be bound to an instance of <code>CustomerModel</code>  on the ViewModel. While the customer is filling out the form since we are in a two way data binding scenario, each time the customer enters or removes a character from the forms input box, <code>SetField()</code> is called and will cause the <code>PropertyChanged</code> event to fire.</p>
<pre><code class="language-cs">public class NewCustomerModel : BindableBase
{
    private string firstName;
    
    public string FirstName
    {
        get =&gt; firstName;
        set
        {
            SetField(ref firstName, value);
        }
    }
}
</code></pre>
<blockquote>
<p><strong>More:</strong> If you need to know more about <code>INotifyPropertyChanged</code> the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.componentmodel.inotifypropertychanged?view=netframework-4.8">Microsoft Docs</a> cover this topic very well.</p>
</blockquote>
<h3 id="model">Model</h3>
<p>With <code>INotifyPropertyChanged</code> out of the way, here is the entire presentation model.</p>
<pre><code class="language-cs">public class NewCustomerModel : BindableBase
{
    [Display(Name = &quot;Customer Number&quot;)]
    public string CustomerNumber { get; set; }

    [Display(Name = &quot;Full Name&quot;)]
    public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;

    private string firstName;
    [Required]
    [Display(Name = &quot;First Name&quot;)]
    public string FirstName
    {
        get =&gt; firstName;
        set
        {
            SetField(ref firstName, value);
            OnPropertyChanged(nameof(FullName));
        }
    }

    private string lastName;
    [Required]
    [Display(Name = &quot;Last Name&quot;)]
    public string LastName
    {
        get =&gt; lastName;
        set
        {
            SetField(ref lastName, value);
            OnPropertyChanged(nameof(FullName));
        }
    }

    [Display(Name = &quot;Address&quot;)]
    public string Address =&gt; $&quot;{Street}, {City}, {State} {PostalCode}&quot;;

    private string street;

    [Required]
    [Display(Name = &quot;Street Address&quot;)]
    public string Street
    {
        get =&gt; street;
        set
        {
            SetField(ref street, value);
            OnPropertyChanged(nameof(Address));
        }
    }
    private string city;

    [Required]
    [Display(Name = &quot;City&quot;)]
    public string City
    {
        get =&gt; city;
        set
        {
            SetField(ref city, value);
            OnPropertyChanged(nameof(Address));
        }
    }
    private string state;

    [Required]
    [Display(Name = &quot;State&quot;)]
    public string State
    {
        get =&gt; state;
        set
        {
            SetField(ref state, value);
            OnPropertyChanged(nameof(Address));
        }
    }
    private string postalCode;

    [Required]
    [Display(Name = &quot;Zip Code&quot;)]
    public string PostalCode
    {
        get =&gt; postalCode;
        set
        {
            SetField(ref postalCode, value);
            OnPropertyChanged(nameof(Address));
        }
    }
}
</code></pre>
<p>There's a few things to point out in this presentation model. First, please note the use of the <strong>Data Annotation</strong> attribute such as <code>[Required]</code>.  You can decorate your properties to provide rich form validation feedback to your users. When the customer is filling out a form and misses a required field it will not pass the model validation and prevent the form from being submitted as well as provide an error message if configured. We will cover this more in the <strong>View</strong> section</p>
<p>The next thing I wanted to point out is I've covered <code>SetField()</code> in the INotifyPropertyChanged section, but there is an additional bit of complexity.</p>
<pre><code class="language-cs">[Display(Name = &quot;Full Name&quot;)]
public string FullName =&gt; $&quot;{FirstName} {LastName}&quot;;
</code></pre>
<p>Note that the <code>FullName</code> property is a <code>{ get; }</code> only concatenation of the customers first and last name.  Since we are forcing the customer to fill out first and last name in separate form field, changing either the first or last name causes the <code>FullName</code> to change.  We want the ViewModel to be informed of these changes to <code>FullName</code>.</p>
<pre><code class="language-cs">private string firstName;
[Required]
[Display(Name = &quot;First Name&quot;)]
public string FirstName
{
    get =&gt; firstName;
    set
    {
        SetField(ref firstName, value);
        OnPropertyChanged(nameof(FullName));
    }
}
</code></pre>
<p>After the <code>SetField()</code> is invoked in the base class, there is an additional call to <code>OnPropertyChanged()</code>, which let's the ViewModel know that in addition to <code>FirstName</code> changing, <code>FullName</code> has also changed.</p>
<h3 id="example-viewmodel-interface">Example ViewModel Interface</h3>
<p>The example ViewModel below will expand on the above model, we'll be using a simplified user story of creating a new customer.</p>
<p>Blazor supports .NET Core's dependency injection out of the box, which makes makes injecting a ViewModel very simple.  In the following ViewModel interface, we'll need our concrete class to have an instance of <code>NewCustomer</code> as well as a method which knows how to create a new customer.</p>
<pre><code class="language-cs">public interface ICustomerCreateViewModel
{
    NewCustomerModel NewCustomer { get; set; }
    void Create();
}
</code></pre>
<p>And the concrete implementation of <code>ICustomerCreateViewModel</code></p>
<pre><code class="language-cs">public class CustomerCreateViewModel : ICustomerCreateViewModel
{
    private readonly ICustomerService _customerService;

    public CustomerCreateViewModel(ICustomerService customerService)
    {
        _customerService = customerService;
    }

    public NewCustomerModel NewCustomer { get; set; } = new NewCustomerModel();

    public void Create()
    {
        //map presentation model to the data layer entity
        var customer = new NewCustomer()
        {
            CustomerNumber = Guid.NewGuid().ToString().Split('-')[0],
            FullName = $&quot;{newCustomer.FirstName} {NewCustomer.LastName}&quot;,
            Address = $&quot;{newCustomer.Address}, {NewCustomer.City}, {newCustomer.State} {NewCustomer.PostalCode}&quot;
        };

        //create
        _customerService.AddNewCustomer(customer);
    }
}
</code></pre>
<h3 id="viewmodel-deep-dive">ViewModel Deep-Dive</h3>
<p>In the constructor we're getting an instance of our <code>ICustomerService</code> which knows how to create new customers when provided the data layer entity called <code>NewCustomer</code></p>
<p>I need to point out that <code>NewCustomer</code> and <code>NewCustomerModel</code> serve two different purposes.  <code>NewCustomer</code> is the data entity, and is a simple POCO. The data entity is the item that is persisted. Of note, in this example, we save the customers full name as a single column in a database, but on the form backed by the presentation model, we actually want the customer to fill out 'First Name' and 'Last Name'</p>
<p>In the ViewModel, the <code>Create()</code> method shows how a <code>NewCustomerModel</code> is mapped to a <code>NewCustomer</code>.  There are some tools that are very good at doing this type of mapping (like AutoMapper), but for this example the amount of code to map between the types is trivial. For reference, here is the data entity.</p>
<pre><code class="language-cs">public class NewCustomer
{
	public string CustomerNumber { get; set; }
	public string FullName { get; set; }
	public string Address { get; set; }
}
</code></pre>
<blockquote>
<p><strong>Opinionated Note:</strong> Presentation models and data entities should be separated into their respective layers.  It is possible to create a single <code>CustomerModel</code> and use it for both presentation and data layers to reduce code duplication, but I highly discourage this practice.</p>
</blockquote>
<h3 id="view">View</h3>
<p>The last and final piece to the MVVM pattern is the View.  The View in the context of Blazor is either a <code>Page</code> or <code>Component</code>, which is either a .razor file, or a .cshtml file and contains Razor code. Razor code is a mix of C# and HTML markup.  In the context of this article, our view will be a customer form that can be filled out, and a button that calls the ViewModel's <code>Create()</code> method when the form has been filled out properly according to the validation rules.</p>
<pre><code class="language-cs">&#64;page &quot;/customer/create&quot;
&#64;using HappyStorage.Common.Ui.Customers
&#64;using HappyStorage.BlazorWeb.Components
&#64;inject Microsoft.AspNetCore.Components.IUriHelper UriHelper
&#64;inject HappyStorage.Common.Ui.Customers.ICustomerCreateViewModel viewModel

&lt;h1&gt;Create Customer&lt;/h1&gt;

&lt;EditForm Model=&quot;&#64;viewModel.NewCustomer&quot; OnValidSubmit=&quot;&#64;HandleValidSubmit&quot;&gt;
    &lt;DataAnnotationsValidator /&gt;
    &lt;ValidationSummary /&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;h3&gt;Name&lt;/h3&gt;
        &lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.FirstName)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.FirstName&quot; /&gt;

        &lt;LabelComponent labelFor=&quot;(() =&gt; viewModel.NewCustomer.LastName)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.LastName&quot; /&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
        &lt;h3&gt;Address&lt;/h3&gt;

        &lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.Street)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.Street&quot; /&gt;

        &lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.City)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.City&quot; /&gt;

        &lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.State)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.State&quot; /&gt;

        &lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.PostalCode)&quot; /&gt;
        &lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.PostalCode&quot; /&gt;
    &lt;/div&gt;
    &lt;br /&gt;
    &lt;button class=&quot;btn btn-primary&quot; type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
    &lt;button class=&quot;btn&quot; type=&quot;button&quot; onclick=&quot;&#64;ReturnToList&quot;&gt;Cancel&lt;/button&gt;
&lt;/EditForm&gt;
</code></pre>
<p>The first thing to note is at the top of the code, and this is how we use dependency injection to get an instance of our ViewModel.</p>
<pre><code class="language-cs">&#64;inject HappyStorage.Common.Ui.Customers.ICustomerCreateViewModel viewModel
</code></pre>
<p>Easy!  Next we need to create the form.  The EditForm needs an instance of a model to bind to, which is provided by the ViewModel already, and a method to call when the user submits a valid form.</p>
<pre><code class="language-cs">&lt;EditForm Model=&quot;&#64;viewModel.NewCustomer&quot; OnValidSubmit=&quot;&#64;HandleValidSubmit&quot;&gt;
...
&lt;/EditForm&gt;
</code></pre>
<p>Next we bind each property to their respective <code>&lt;input&gt;</code>'s, Blazor has some built in <code>&lt;Input***&gt;&lt;/Input***&gt;</code> helpers which help you accomplish the binding.  They are still under development and you may find some features are lacking at the time of writing. Please refer to the docs in the note below for more up to date info.</p>
<blockquote>
<p><strong>Note</strong> the <code>&lt;LabelComponent /&gt;</code> is something I've created as a replacement for the <code>asp-for</code> tag-helper that retrieves the <code>DisplayAttribute</code> from the presentation model classes. The code is available in the GitHub repository listed at the top.</p>
</blockquote>
<pre><code class="language-cs">&lt;LabelComponent labelFor=&quot;&#64;(() =&gt; viewModel.NewCustomer.FirstName)&quot; /&gt;
&lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.FirstName&quot; /&gt;

&lt;LabelComponent labelFor=&quot;(() =&gt; viewModel.NewCustomer.LastName)&quot; /&gt;
&lt;InputText class=&quot;form-control&quot; bind-Value=&quot;&#64;viewModel.NewCustomer.LastName&quot; /&gt;
</code></pre>
<p>The magic here is <code>bind-Value</code> which binds our <code>&lt;InputText /&gt;</code> text box to the value of the ViewModels instance of the <code>NewCustomerModel</code> presentation model.</p>
<blockquote>
<p><strong>Note:</strong> Full documentation on <a href="https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-3.0">Blazor Forms and Validation</a></p>
</blockquote>
<p>Last but not least we'll need some code to call our ViewModel's <code>Create()</code> method when the form is submitted and valid, as well as the <code>onclick=ReturnToList</code> I've defined for the <strong>Cancel</strong> button.</p>
<pre><code class="language-cs">&#64;functions {
    private void HandleValidSubmit()
    {
        viewModel.Create();
        ReturnToList();
    }

    private void ReturnToList()
    {
        UriHelper.NavigateTo(&quot;/customers&quot;);
    }
}
</code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>That's it! In summary, I've covered what MVVM is, how Blazor can benefit from it as well as an in depth look at a simple example of how we can create a form with validation and rich feed back to the user.  It is also important to reiterate that this example works not only in Blazor, but can be re-used in Windows Presentation Foundation (WPF) desktop applications as well as other platforms.  Please check out the <a href="https://github.com/EntityAdam/HappyStorage">GitHub repository</a> as I continue to develop and expand on this concept.</p>


        

      </div>
    </div>
  </div>

  <hr>

  <!-- Footer -->
  <footer>
  <div class="container">
    <div class="row">
      <div class="col-md-12 text-center">
        <p class="copyright">Copyright &#xA9; 2023</p>

        <ul class="list-inline text-center small">
            <li class="list-inline-item">
              <a href="/feed.rss"><i class="fa fa-rss"></i> RSS Feed</a>
            </li>
            <li class="list-inline-item">
              <a href="/feed.atom"><i class="fa fa-rss"></i> Atom Feed</a>
            </li>
        </ul>
        <br />
        <div class="font-weight-bold small"><a href="https://statiq.dev">Generated by Statiq</a></div>
      </div>
    </div>
  </div>
</footer>


  <!-- Scripts -->
  <script src='/vendor/bootstrap/js/bootstrap.bundle.min.js'></script>
  <script src='/vendor/startbootstrap-clean-blog/js/scripts.js'></script>
  <script src='/js/clean-blog.js'></script>
  

  

</body>

</html>
